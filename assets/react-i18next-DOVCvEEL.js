var q=Object.defineProperty;var A=(e,t,s)=>t in e?q(e,t,{enumerable:!0,configurable:!0,writable:!0,value:s}):e[t]=s;var L=(e,t,s)=>A(e,typeof t!="symbol"?t+"":t,s);import{r}from"./react-B1CnsdDo.js";const B=(...e)=>{console!=null&&console.warn&&(g(e[0])&&(e[0]=`react-i18next:: ${e[0]}`),console.warn(...e))},P={},w=(...e)=>{g(e[0])&&P[e[0]]||(g(e[0])&&(P[e[0]]=new Date),B(...e))},k=(e,t)=>()=>{if(e.isInitialized)t();else{const s=()=>{setTimeout(()=>{e.off("initialized",s)},0),t()};e.on("initialized",s)}},M=(e,t,s)=>{e.loadNamespaces(t,k(e,s))},j=(e,t,s,a)=>{g(s)&&(s=[s]),s.forEach(p=>{e.options.ns.indexOf(p)<0&&e.options.ns.push(p)}),e.loadLanguages(t,k(e,a))},W=(e,t,s={})=>!t.languages||!t.languages.length?(w("i18n.languages were undefined or empty",t.languages),!0):t.hasLoadedNamespace(e,{lng:s.lng,precheck:(a,p)=>{var n;if(((n=s.bindI18n)==null?void 0:n.indexOf("languageChanging"))>-1&&a.services.backendConnector.backend&&a.isLanguageChangingTo&&!p(a.isLanguageChangingTo,e))return!1}}),g=e=>typeof e=="string",G=e=>typeof e=="object"&&e!==null,J=/&(?:amp|#38|lt|#60|gt|#62|apos|#39|quot|#34|nbsp|#160|copy|#169|reg|#174|hellip|#8230|#x2F|#47);/g,K={"&amp;":"&","&#38;":"&","&lt;":"<","&#60;":"<","&gt;":">","&#62;":">","&apos;":"'","&#39;":"'","&quot;":'"',"&#34;":'"',"&nbsp;":" ","&#160;":" ","&copy;":"©","&#169;":"©","&reg;":"®","&#174;":"®","&hellip;":"…","&#8230;":"…","&#x2F;":"/","&#47;":"/"},Y=e=>K[e],Q=e=>e.replace(J,Y);let E={bindI18n:"languageChanged",bindI18nStore:"",transEmptyNodeValue:"",transSupportBasicHtmlNodes:!0,transWrapTextNodes:"",transKeepBasicHtmlNodesFor:["br","strong","i","p"],useSuspense:!0,unescape:Q};const X=(e={})=>{E={...E,...e}},Z=()=>E;let H;const _=e=>{H=e},D=()=>H,ae={type:"3rdParty",init(e){X(e.options.react),_(e)}},O=r.createContext();class V{constructor(){L(this,"getUsedNamespaces",()=>Object.keys(this.usedNamespaces));this.usedNamespaces={}}addUsedNamespaces(t){t.forEach(s=>{var a;(a=this.usedNamespaces)[s]??(a[s]=!0)})}}const ee=(e,t)=>{const s=r.useRef();return r.useEffect(()=>{s.current=e},[e,t]),s.current},U=(e,t,s,a)=>e.getFixedT(t,s,a),te=(e,t,s,a)=>r.useCallback(U(e,t,s,a),[e,t,s,a]),oe=(e,t={})=>{var R,z,F,v;const{i18n:s}=t,{i18n:a,defaultNS:p}=r.useContext(O)||{},n=s||a||D();if(n&&!n.reportNamespaces&&(n.reportNamespaces=new V),!n){w("You will need to pass in an i18next instance by using initReactI18next");const i=(u,l)=>g(l)?l:G(l)&&g(l.defaultValue)?l.defaultValue:Array.isArray(u)?u[u.length-1]:u,c=[i,{},!1];return c.t=i,c.i18n={},c.ready=!1,c}(R=n.options.react)!=null&&R.wait&&w("It seems you are still using the old wait option, you may migrate to the new useSuspense behaviour.");const m={...Z(),...n.options.react,...t},{useSuspense:S,keyPrefix:b}=m;let o=p||((z=n.options)==null?void 0:z.defaultNS);o=g(o)?[o]:o||["translation"],(v=(F=n.reportNamespaces).addUsedNamespaces)==null||v.call(F,o);const d=(n.isInitialized||n.initializedStoreOnce)&&o.every(i=>W(i,n,m)),$=te(n,t.lng||null,m.nsMode==="fallback"?o:o[0],b),T=()=>$,x=()=>U(n,t.lng||null,m.nsMode==="fallback"?o:o[0],b),[C,h]=r.useState(T);let y=o.join();t.lng&&(y=`${t.lng}${y}`);const I=ee(y),f=r.useRef(!0);r.useEffect(()=>{const{bindI18n:i,bindI18nStore:c}=m;f.current=!0,!d&&!S&&(t.lng?j(n,t.lng,o,()=>{f.current&&h(x)}):M(n,o,()=>{f.current&&h(x)})),d&&I&&I!==y&&f.current&&h(x);const u=()=>{f.current&&h(x)};return i&&(n==null||n.on(i,u)),c&&(n==null||n.store.on(c,u)),()=>{f.current=!1,n&&(i==null||i.split(" ").forEach(l=>n.off(l,u))),c&&n&&c.split(" ").forEach(l=>n.store.off(l,u))}},[n,y]),r.useEffect(()=>{f.current&&d&&h(T)},[n,b,d]);const N=[C,n,d];if(N.t=C,N.i18n=n,N.ready=d,d||!d&&!S)return N;throw new Promise(i=>{t.lng?j(n,t.lng,o,()=>i()):M(n,o,()=>i())})};function ie({i18n:e,defaultNS:t,children:s}){const a=r.useMemo(()=>({i18n:e,defaultNS:t}),[e,t]);return r.createElement(O.Provider,{value:a},s)}export{ie as I,ae as i,oe as u};
